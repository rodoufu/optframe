// ===================================
// Main.cpp file generated by OptFrame
// Project NumberPartitionProblem
// ===================================

#include <iostream>
#include <iomanip>
#include <fstream>
#include <memory>
#include <utility>
#include <tuple>
#include <chrono>
#include <future>

#include <sys/types.h>
#include <dirent.h>

#include <stdlib.h>
#include <math.h>

#include "OptFrame/Heuristics/SA/BasicSimulatedAnnealing.hpp"
#include "OptFrame/Heuristics/LocalSearches/BestImprovement.hpp"
#include "OptFrame/Heuristics/LocalSearches/FirstImprovement.hpp"
#include "OptFrame/Heuristics/LocalSearches/HillClimbing.hpp"
#include "OptFrame/Heuristics/LocalSearches/RandomDescentMethod.hpp"
#include "OptFrame/Util/CheckCommand.hpp"
#include "OptFrame/SingleObjSearch.hpp"
#include "OptFrame/Util/RandGenMersenneTwister.hpp"
#include "OptFrame/Util/printable.h"

#include "NPP.h"

using namespace std;
using namespace optframe;
using namespace NPP;

void check(RandGenMersenneTwister &rg) {
    // Initialize here all your OptFrame components
    // (ProblemInstance, Evaluator, Constructive, ...)
    unique_ptr<ifstream> ifs(new std::ifstream("input/example.in", std::ifstream::in));
    Scanner scanner(ifs.get());
    ProblemInstance p(scanner);

    CheckCommand<RepNPP> check;
    MyEvaluator ev(p);
    check.add(ev);

    ConstructiveGreedy c1(p);
    ConstructiveRand c2(p, rg);
    check.add(c1);
    check.add(c2);

    NSSeqBitFlip ns1(p, rg);
    check.add(ns1);

    check.run(10, 10);
}

tuple<SolutionNPP, Evaluation, double, SolutionNPP, Evaluation, double>
solveSA(RandGenMersenneTwister &rg, string instance, bool print = false) {
    unique_ptr<ifstream> ifs(new std::ifstream(instance, std::ifstream::in));
    Scanner scanner(ifs.get());
    ProblemInstance p(scanner);
    ifs->close();

    MyEvaluator ev(p);
    NSSeqBitFlip ns1(p, rg);
    ConstructiveGreedy c1(p);
    ConstructiveRand c2(p, rg);

    NSSeq<RepNPP> *nsseq_bit = &ns1;

    auto start = chrono::steady_clock::now();
    const double alpha = 0.98;
    const int SAmax = 100;
    double Ti = 900.0;
    BasicSimulatedAnnealing<RepNPP, MY_ADS> sa(ev, c2, *nsseq_bit, alpha, SAmax, Ti, rg, print);
    SOSC sosc; // stop criteria
    unique_ptr<pair<SolutionNPP, Evaluation>> r(sa.search(sosc));
    auto end = chrono::steady_clock::now();
    double saTime = chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0;
    if (print) {
        r->first.print();
    }
    if (print) {
        r->second.print();
    }

    BestImprovement<RepNPP, MY_ADS> bi(ev, ns1);
    FirstImprovement<RepNPP, MY_ADS> fi(ev, ns1);

    auto sol = r->first;
    Evaluation e = ev.evaluate(sol.getR(), sol.getADSptr());

    vector<std::future<pair<CopySolution<RepNPP, MY_ADS> &, Evaluation &>>> futures;
    start = chrono::steady_clock::now();
    futures.push_back(std::async([&]() {
        HillClimbing<RepNPP, MY_ADS> sd1(ev, bi);
        return sd1.search(sol, e, sosc);
    }));

    futures.push_back(std::async([&]() {
        HillClimbing<RepNPP, MY_ADS> pm(ev, fi);
        return pm.search(sol, e, sosc);
    }));

    futures.push_back(std::async([&]() {
        RandomDescentMethod<RepNPP, MY_ADS> rdm(ev, ns1, 10);
        return rdm.search(sol, e, sosc);
    }));

    bool first = true;
    pair<CopySolution<RepNPP, MY_ADS> &, Evaluation &> best(r->first, r->second);
    for (auto &fut : futures) {
        auto value = fut.get();
        if (first) {
            best = value;
            first = false;
        } else if ((ev.isMinimization() && value.second.evaluation() < value.second.evaluation()) ||
                   (ev.isMaximization() && value.second.evaluation() > value.second.evaluation())) {
            best = value;
        }
        if (print) {
            value.second.print();
        }
    }
    end = chrono::steady_clock::now();

    double lsTime = chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0;
    return make_tuple(r->first, r->second, saTime, best.first, best.second, lsTime);
}

int main(int argc, char **argv) {
    RandGenMersenneTwister rg; // not using system rand() anymore

    check(rg);

    string folder = "input";
    DIR *dirp = opendir(folder.c_str());
    struct dirent *dp;
    cout << "file;SA;timeSA;LS;timeLS" << endl;
    while ((dp = readdir(dirp)) != nullptr) {
        string file = dp->d_name;
        if (file != "." && file != ".." && file != "example.in" && file.find_last_of(".in") == file.length() - 1) {
            cerr << file << endl;
            for (int cont = 0; cont < 30; ++cont) {
                auto resp = solveSA(rg, folder + "/" + file);
                cout <<
                     file << ";" <<
                     std::fixed << std::setprecision(0) << get<1>(resp).evaluation() << ";" <<
                     std::fixed << std::setprecision(5) << get<2>(resp) << ";" <<
                     std::fixed << std::setprecision(0) << get<4>(resp).evaluation() << ";" <<
                     std::fixed << std::setprecision(5) << get<5>(resp) << "" <<
                     endl;
            }
        }
    }
    closedir(dirp);

    cout << "Program ended successfully" << endl;

    return 0;
}
