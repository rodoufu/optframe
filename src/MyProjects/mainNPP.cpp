// ===================================
// Main.cpp file generated by OptFrame
// Project NumberPartitionProblem
// ===================================

#include <iostream>
#include <fstream>
#include <memory>
#include <utility>

#include <stdlib.h>
#include <math.h>

// Breaking
#include "../OptFrame/Heuristics/SA/BasicSimulatedAnnealing.hpp"
#include "../OptFrame/Heuristics/LocalSearches/BestImprovement.hpp"
#include "../OptFrame/Heuristics/LocalSearches/FirstImprovement.hpp"
#include "../OptFrame/Heuristics/LocalSearches/HillClimbing.hpp"
#include "../OptFrame/Heuristics/LocalSearches/RandomDescentMethod.hpp"
#include "../OptFrame/Util/CheckCommand.hpp"
#include "../OptFrame/SingleObjSearch.hpp"
#include "../OptFrame/Util/RandGenMersenneTwister.hpp"
#include "../OptFrame/Util/printable.h"

#include "NPP.h"

using namespace std;
using namespace optframe;
using namespace NPP;

int main(int argc, char **argv) {
    RandGenMersenneTwister rg; // not using system rand() anymore

    // Initialize here all your OptFrame components
    // (ProblemInstance, Evaluator, Constructive, ...)

    unique_ptr <ifstream> ifs(new std::ifstream("input/example.in", std::ifstream::in));
    Scanner scanner(ifs.get());
    ProblemInstance p(scanner);
    ifs->close();

    MyEvaluator ev(p);

    NSSeq2Opt ns1(p, rg);
    NSSeqSwap ns2(p, rg);

    ConstructiveGreedy c1(p);
    ConstructiveRand c2(p);

    CheckCommand<RepNPP> check;
    check.add(ev);
    check.add(c1);
    check.add(c2);
    check.add(ns1);
    check.add(ns2);

    check.run(10, 10);

    NSSeq<RepNPP> *nsseq_bit = &ns1;

    BasicSimulatedAnnealing <RepNPP, MY_ADS> sa(ev, c1, *nsseq_bit, 0.98, 100, 900.0, rg);
    SOSC sosc; // stop criteria
    unique_ptr<pair<SolutionNPP, Evaluation>> r(sa.search(sosc));
    r->first.print();
    r->second.print();

    BestImprovement<RepNPP, MY_ADS> bi(ev, ns1);
    FirstImprovement<RepNPP, MY_ADS> fi(ev, ns1);
    HillClimbing<RepNPP, MY_ADS> sd(ev, bi);
    HillClimbing<RepNPP, MY_ADS> pm(ev, fi);
    RandomDescentMethod<RepNPP, MY_ADS> rdm(ev, ns1, 10);

    auto sol = r->first;
    Evaluation e = ev.evaluate(sol.getR(), sol.getADSptr());
    sd.search(sol, e, sosc).second.print();
    pm.search(sol, e, sosc).second.print();
    rdm.search(sol, e, sosc).second.print();

    cout << "Program ended successfully" << endl;

    return 0;
}
